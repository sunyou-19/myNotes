###定义
（1）数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。数据元素相互之间的关系称为结构。数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。
（2）数据的逻辑结构：是指数据之间的逻辑关系，与数据的存储结构无关，是对数据关系的抽象描述。包括线性结构（一般线性表、受限线性表、数组）、非线性结构（集合、树、图）
（3）数据的存储结构：顺序存储、链式存储、索引存储、哈希存储。
（4）线性表：具有相同数据类型的n个数据元素的有限序列。
（5）顺序表：线性表的顺序存储。其逻辑顺序与物理顺序相同，是随机存取的存储结构。
（6）单链表：线性表的链式存储。建立单链表的两种方式：头插法、尾插法
（7）栈：是一种受限线性表，只允许在一端插入和删除。其特性为“先进后出，后进先出”
（8）队列：是一种首先线性表，只允许在一端插入，在另一端删除。其特性为“先进先出”
（9）循环队列：牺牲一个单元区分队满和队空；增加记录队列元素个数的数据成员；增加标记flag，当出队时标记为0，当入队时标记为1。
（10）栈的应用：括号匹配、函数调用、迷宫问题、中缀表达式转后缀表达式，后缀表达式计算。
（11）队列的应用：二叉树的层次遍历、缓冲区、就绪队列、
（12）串：字符串，是由零个或多个字符组成的有序序列。
串中任意多个连续的字符组成的子序列称为该串的子串，相应包含该字串的串称为主串。
（13）简单的模式匹配算法：
（14）KMP算法：在主串与模式串匹配时，主串不需要回溯，按照next数组，对模式串进行回溯。
（15）树是n个结点的有限集，树的根结点没有前驱，除了根结点外的所有结点有且只有一个前驱，树中所有结点可以有零个或多个后继。树的结点数等于所有结点的度数之和加1。有序树和无序树
（16）二叉树：每个结点最多有两个子树，并且二叉树的子树有左右之分，其次序不能任意颠倒。
（17）满二叉树：一个高度为h、结点个数为 $2^h-1$个结点的二叉树。
（18）完全二叉树：高度为h、有n个结点，当且仅当其每个结点都与高度h的满二叉树中编号为1~n的结点一一对应。
（19）二叉排序树：根结点的值大于左子树的值，小于右子树的值。
（20）平衡二叉树：左右子树高度之差不超过1的二叉排序树。
（21）二叉树的四种遍历：先序遍历、中序遍历、后序遍历、层次遍历。
1. 先序遍历：
2. 中序遍历：二叉排序树、
3. 后序遍历：释放二叉树、
4. 层次遍历：将根结点入队，将根结点出队，并访问出队元素，将该出队结点的左孩子和右孩子入队，循环该过程，直到队列为空。
（23）线索二叉树：利用二叉树结点的空指针使其指向其前驱或后继。n个结点的二叉树的空指针为n+1个。【**有待进一步学习**】
（24）树的存储：双亲表示法、孩子表示法、孩子兄弟表示法（方便地实现树转换为二叉树地操作）
（25）树、森林、二叉树的遍历关系。

| 树 | 森林 |  二叉树  |
|----|----|----|
| 先根遍历   | 先序遍历   |  先序遍历  |
|  后根遍历  |  中序遍历  |  中序遍历  |

（26）并查集：简单的集合表示，通常用树和森林的双亲作为并查集的存储结构，每一个子集合用一棵树表示。通常用数组下标代替元素名，用根结点的下标代表子集合名，根结点的双亲结点为负数。
应用：计算树的连通分量、求解最小生成树的Kruskal算法、

（27）二叉排序树：中序遍历为递增有序序列的二叉树。
二叉排序树的删除：
1. 删除结点为叶子结点，直接删除
2. 只有左子树非空或者只有右子树非空，则让该节点子树成为该结点父结点的子树
3. 若该结点左右子树都非空，则让该结点的中序遍历中的直接前驱或后继代替该结点，转化为1或2的情况。

（28）平衡二叉树的插入：
1. 在二叉排序树中插入（或删除）一个结点时，检查其插入的入路径上的结点是否因为此次操作导致了不平衡，若导致不平衡，找到离插入结点最近的平衡因子绝对值大于1的结点A，
2. 若在A的左孩子B的左子树上插入结点，A的左孩子代替A成为根结点，A变为其右孩子，A的左孩子的右子树变为A的左子树。这是以A为根进行的右旋。
3. 若在A的右孩子B的右子树上插入结点，A的右孩子代替A成为根结点，A变为其左孩子，A的右孩子的左子树变为A的右子树。这是以A为根进行的左旋。
4. 若在A的左孩子B的右子树插入，以B为根进行左旋，再以A为根进行右旋。
5. 若在A的右孩子B的左子树插入，以B为根进行右旋，再以A为根进行左旋。

（29）哈夫曼树：带权路径长度最小的二叉树，也称为最优二叉树。
哈夫曼树的构造：
1. 将n个结点分别作为n棵仅含一个结点的森林
2. 从中找出权值最小的两个结点，并构造新结点，使该结点的左右指针两个权值最小的结点，从森林中删除这两个结点，新结点的权值为，其两个孩子权值之和。并将这个新结点加入森林
3. 重复 2 直到森林中只有一颗树。

哈夫曼编码：可变长度编码，是一种前缀编码（没有一个编码使另一个编码的前缀），根据要编码数据的使用频率，构造哈夫曼树。利用哈夫曼树可以设计出总长度最短的二进制前缀编码。

（30）
1. 简单图：不存在重复的边，不存在顶点到自身的边。
2. 完全图：对于无向图，任意两点之间存在一条边，即若有n个顶点，则有n*(n-1)/2条边。对于有向图，任意两个顶点存在一对方向相反的弧。
3. 连通图：在无向图中，任意两点存在路径。
4. 连通分量：无向图的极大连通子图。
5. 强连通图：在有向图中，任意两点存在路径。
6. 生成树：连通图的生成树是包含图中全部顶点的一个极小连通子图。若图有n个顶点，则它的生成树有n-1条边。
7. 简单路径：在路径序列中，顶点不重复出现的路径称为简单路径。

（31）
1. 邻接矩阵：使用一个二维数组存储顶点之间的邻接关系，A[i][j]表示顶点i和顶点j的邻接关系。
2. 邻接表法：为每个顶点建立一个单链表，单链表的结点存储与该顶点有邻接关系的边。
3. 十字链表：一种有向图的链式存储。
4. 邻接多重表：一种无向图的链式存储。

（32）
1. 广度优先遍历（BFS）：类似二叉树的层次遍历，将顶点V入队，将顶点V出队并访问，将出队元素标记为已访问，将与出队元素相邻且未被访问的顶点入队，循环直至队列为空。邻接表的时间复杂度为O(|V|+|E|)，邻接矩阵的时间复杂度为O($|V|^2$)，Dijkstra和prim也有类似的思想。可以使用广度优先遍历求解无权图单源最短路径。
2. 深度优先遍历（DFS）：先访问顶点V，再访问与V邻接且未被访问的顶点.